# Локальный конвейер сборки проекта
## Описание
Проект содержит реализацию локального конвейера сборки для тестового задания. <br>
Конвейер выполняет сборку проекта на языке С в различных режимах: 
- **Release**: Оптимизированный `.deb` (strip + static)
- **Debug**: `.deb` + отдельный *debug symbols* пакет (gdb-ready)
- **Coverage**: `.deb` + gcov/lcov + html-report о покрытии тестами

*В качестве исходных файлов используется код проекта iperf3 - [ссылка на репозиторий](https://github.com/esnet/iperf)*

**Архитектура проекта**
```
build.sh -> Docker (multi-stage) -> build_mode.sh -> .deb artifacts
├── inst_dir/artifacts/{release,debug,coverage}/*.deb # deb пакеты сборок
├── inst_dir/report/build_report_*.txt # отчеты о сборке
├── inst_dir/ccache_dir/ (persistent cache) # Кэш для ускорения сборки
└── inst_dir/coverage_last.txt # последний отчет о покрытии тестами
```
**Файлы проекта**
| Файл          | Назначение                                                        |
| ------------- | ----------------------------------------------------------------- |
| build.sh      | Главная точка входа CI/CD. Управляет Docker образом + параметрами |
| Dockerfile    | Multi-stage: git clone -> build environment                       |
| build_mode.sh | Логика сборки: ./configure -> make -> make install -> dpkg-deb    |
| inst_dir/     | Workspace: artifacts, reports, ccache                             |

## Модернизация и улучшения конвейера
1. Ручная сборка `.deb` через `dpkg-deb` вместо dh_make/debuild

| Стандарт                         | Мой подход                    | Обоснование                                                                                                                       |
| -------------------------------- | ----------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| dh_make -> debian/rules -> debuild | ./configure -> make -> dpkg-deb | Полный контроль над: <br> - Debug symbols workflow<br> - Custom control файлы <br> - Multi-package output (binary+debug) <br> - Coverage в .deb |

**Почему лучше:**
```
# Debug: 2 отдельных .deb (binary + symbols)
iperf3_1.0.1_debug_amd64.deb        # stripped binary + debuglink
iperf3-debug_1.0.1_debug_amd64.deb  # /usr/lib/debug/usr/bin/iperf3.debug
```
dh_make невозможно использовать в качестве инструмента для данного задания.

2. Multi-Stage Docker

**Почему лучше:**
При данном подходе мы сперва клонируем репозиторий, после чего копируем **только** бинарные файлы в основной образ (где будет происходить сборка).<br> Это позволяет избежать необходимости устанавливать много зависимостей на хостовой машине и упрощает процесс развертывания приложения.

| Одностадийный       | Multi-stage         | Выигрыш          |
| ------------------- | ------------------- | ---------------- |
| ~900MB              | ~800MB              | На 12% меньше размер |
| Весь toolchain      | Только runtime deps | Быстрее pull     |

3. Autotools Workflow (bootstrap.sh -> configure.sh -> make)

iperf3 — официальный autotools проект (ESnet), ./bootstrap.sh генерирует configure.


1. `Dockerfile` — рецепт сборки окружения для компиляции и тестирования проекта.
2. `build.sh` — управляющий скрипт конвейера, запускающий сборку в нужном режиме.
3. `build_mode.sh` — скрипт для запуска сборки в нужном режиме.
4. `artifacts/` — итоговые deb/rpm пакеты и отчеты покрытия.
5. `reports/` — файлы истории build_report_{date_time}.txt.

---
## Использование
Основной сценарий работы - запуск скрипта `build.sh` с нужным режимом сборки:
```
./build.sh release
./build.sh debug
./build.sh coverage
```

Внутри скрипта:
- Проверяется наличие локального Docker-образа для сборки проекта
- При отсутствии образа запускается его сборка, затем поднимается контейнер
- В контейнере выполняется сборка и упаковка проекта в deb/rpm, а также дополнительные шаги в зависимости от режима

---
## Поведение в разных режимах
**Release**:
- Включены оптимизации компилятора
- Выполняется `strip` бинарника для удаления отладочной информации
- На выходе формируется deb/rpm пакет с включением номера ревизии проеекта в имя файла, например `iperf3_<revision_num>_amd54.deb`

**Debug**:
- Сборка с отладочными символами без `strip`
- Формируется deb/rpm пакет с номером ревизии
- Дополнительно сохраняется артефакт с отладочной информацией в формате `iperf3-debug-<revision_num>.dbg`

**Coverage**:
-
